Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії



Звіт до практичного завдання №2
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Методи рефакторинґу коду мовою C# для веб-розробки з використанням фреймворку ASP.NET»







Виконав 	
ст. гр. ПЗПІ-23-3                                                               			Чуваєв А.О.
Перевірив
ст. викладач катедри ПІ 					Сокорчук І.П.





                                                                                     
Харків 2025

2 ЗАВДАННЯ
     Мета роботи: 
     Обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code», навести приклади власного коду з курсових, лабораторних або інших проєктів, який потребує покращення, та продемонструвати застосування обраних методів, супроводжуючи кожен метод рефакторингу описом проблеми, кодом до і після застосування методу, а також поясненням переваг використаного підходу для покращення якості, читабельності та підтримуваності програмного забезпечення.




3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Методи рефакторингу програмного коду
     У ході виконання практичної роботи було досліджено три основні методи рефакторингу програмного коду за методологією Мартіна Фаулера: Extract Method (Виділення методу), Replace Conditional with Polymorphism (Заміна умовної логіки поліморфізмом) та Simplify Conditional Expressions (Спрощення умовних виразів).
     Рефакторинг — це процес зміни внутрішньої структури програмного коду без зміни його зовнішньої поведінки. Основною метою рефакторингу є покращення читабельності коду, зменшення цикломатичної складності, полегшення підтримки та розширення програмного забезпечення, а також усунення дублювання коду.
3.2 Метод Extract Method (Виділення методу)
     Метод Extract Method полягає у виділенні фрагментів програмного коду у окремі методи для покращення читабельності та усунення дублікації. Цей метод застосовується у випадках, коли метод перевищує 20-30 рядків коду, містить дублюючі фрагменти або виконує декілька різних відповідальностей.
     Під час виконання роботи було розглянуто приклад класу OrderService, який містив один метод ProcessOrderAsync розміром понад 60 рядків. Метод виконував чотири різні відповідальності: валідацію замовлення, розрахунок загальної суми, застосування знижки та відправку електронного листа.
Приклад коду до рефакторингу:
        01  public async Task<OrderResult> ProcessOrderAsync(Order order)
        02  {
        03      // Валідація замовлення (15 рядків)
        04      if (order == null)
        05          throw new ArgumentNullException(nameof(order));
        06      if (order.Items == null || order.Items.Count == 0)
        07          throw new InvalidOperationException("Order must have items");
        08      foreach (var item in order.Items)
        09      {
        10          if (item.Quantity <= 0)
        11              throw new InvalidOperationException($"Invalid quantity for item {item.ProductId}");
        12      }
        13      
        14      // Розрахунок суми та застосування знижки
        15      decimal total = 0;
        16      foreach (var item in order.Items)
        17      {
        18          var product = await _productRepository.GetByIdAsync(item.ProductId);
        19          total += product.Price * item.Quantity;
        20      }
        21      
        22      if (order.Customer.IsPremium)
        23          total = total * 0.9m;
        24      else if (total > 1000)
        25          total = total * 0.95m;
        26      
        27      // ... інший код
        28  }
     Після застосування методу Extract Method код було розділено на чотири окремі методи, кожен з яких виконує одну конкретну відповідальність: ValidateOrder(), CalculateTotalAsync(), CalculateDiscount() та SendOrderConfirmationAsync(). Основний метод ProcessOrderAsync тепер читається як чіткий алгоритм і містить лише 8 рядків коду.
Приклад коду після рефакторингу:
        01  public async Task<OrderResult> ProcessOrderAsync(Order order)
        02  {
        03      ValidateOrder(order);
        04      var total = await CalculateTotalAsync(order);
        05      var discount = CalculateDiscount(order, total);
        06      order.Total = total - discount;
        07      
        08      await _orderRepository.SaveAsync(order);
        09      await SendOrderConfirmationAsync(order);
        10      
        11      return new OrderResult { Success = true, OrderId = order.Id };
        12  }
     Переваги застосування даного методу включають: покращену читабельність коду, можливість повторного використання виділених методів, спрощення тестування (кожен метод може бути протестований окремо) та полегшення підтримки коду (зміни вносяться в одному місці).
3.3 Метод Replace Conditional with Polymorphism
     Метод Replace Conditional with Polymorphism передбачає заміну умовної логіки (конструкції if/else або switch) на поліморфізм для покращення розширюваності та дотримання принципу Open/Closed з методології SOLID.
     У роботі було проаналізовано клас для обробки платежів, який містив велику конструкцію switch (понад 70 рядків) для обробки різних типів платежів: кредитні картки, PayPal та банківські перекази. Кожна гілка switch містила специфічну логіку валідації та обробки платежу, що призводило до порушення принципу Open/Closed — для додавання нового типу платежу необхідно було модифікувати існуючий метод.
Приклад коду до рефакторингу:
        01  public async Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request)
        02  {
        03      switch (request.PaymentType)
        04      {
        05          case PaymentType.CreditCard:
        06              if (string.IsNullOrEmpty(request.CardNumber))
        07                  throw new ValidationException("Card number required");
        08              var result = await _creditCardGateway.ChargeAsync(...);
        09              return new PaymentResult { Success = result.Success, ... };
        10          
        11          case PaymentType.PayPal:
        12              if (string.IsNullOrEmpty(request.PayPalEmail))
        13                  throw new ValidationException("PayPal email required");
        14              var paypalResult = await _paypalGateway.ProcessAsync(...);
        15              return new PaymentResult { Success = paypalResult.Success, ... };
        16          
        17          // ... інші випадки
        18          
        19          default:
        20              throw new NotSupportedException(...);
        21      }
        22  }
     Після рефакторингу було створено інтерфейс IPaymentHandler та окремі класи-обробники для кожного типу платежу: CreditCardPaymentHandler, PayPalPaymentHandler, BankTransferPaymentHandler. Також було реалізовано фабрику PaymentHandlerFactory для вибору відповідного обробника на основі типу платежу.
Приклад коду після рефакторингу:
        01  public interface IPaymentHandler
        02  {
        03      Task<PaymentResult> ProcessAsync(PaymentRequest request);
        04      bool CanHandle(PaymentType paymentType);
        05  }
        06  
        07  public class CreditCardPaymentHandler : IPaymentHandler
        08  {
        09      public bool CanHandle(PaymentType type) => type == PaymentType.CreditCard;
        10      
        11      public async Task<PaymentResult> ProcessAsync(PaymentRequest req)
        12      {
        13          ValidateCreditCard(req);
        14          var result = await _gateway.ChargeAsync(req.Amount, req.CardNumber);
        15          return new PaymentResult { Success = result.Success, ... };
        16      }
        17  }
        18  
        19  public class PaymentProcessor
        20  {
        21      public async Task<PaymentResult> ProcessPaymentAsync(PaymentRequest req)
        22      {
        23          var handler = _factory.GetHandler(req.PaymentType);
        24          return await handler.ProcessAsync(req);
        25      }
        26  }
     Переваги цього підходу: для додавання нового типу платежу достатньо створити новий клас-обробник без зміни існуючого коду (дотримання принципу Open/Closed), кожен обробник можна тестувати незалежно, чітке розділення відповідальностей між класами.
3.4 Метод Simplify Conditional Expressions
     Метод Simplify Conditional Expressions призначений для спрощення складних умовних виразів, зменшення глибини вкладеності та покращення читабельності коду. Цей метод застосовується при наявності глибоко вкладених конструкцій if/else, подвійних заперечень, дублювання умов або складних тернарних операторів.
     Було розглянуто приклад методу перевірки доступу користувача до ресурсу, який мав 7-8 рівнів вкладеності конструкцій if/else. Це ускладнювало читання коду, розуміння логіки та тестування всіх можливих гілок виконання програми.
Приклад коду до рефакторингу (фрагмент):
        01  public bool CanUserAccessResource(User u, Resource r, string a) {
        02      if (u != null) {
        03          if (!u.IsDeleted) {
        04              if (u.IsActive) {
        05                  if (r != null) {
        06                      if (!r.IsDeleted) {
        07                          if (u.Role == "Admin") return true;
        08                          else if (u.Role == "Manager") {
        09                              if (r.OwnerId == u.Id) return true;
        10                              else if (a == "Read") return true;
        11                              // ... ще більше вкладеності
        12                          }
        13                      }
        14                  }
        15              }
        16          }
        17      }
        18      return false;
     Під час рефакторингу було застосовано техніку раннього виходу (guard clauses) та використано сучасні конструкції C# — switch expressions. Також складні умови було винесено у окремі методи з описовими іменами.
Приклад коду після рефакторингу:
        01  public bool CanUserAccessResource(User user, Resource resource, string action)
        02  {
        03      if (!IsValidUser(user) || !IsValidResource(resource))
        04          return false;
        05      
        06      return user.Role switch
        07      {
        08          "Admin" => true,
        09          "Manager" => CanManagerAccess(user, resource, action),
        10          "User" => CanUserAccess(user, resource, action),
        11          _ => false
        12      };
        13  }
        14  
        15  private bool IsValidUser(User user)
        16      => user != null && !user.IsDeleted && user.IsActive;
        17  
        18  private bool IsValidResource(Resource resource)
        19      => resource != null && !resource.IsDeleted; 
     Результатом застосування методу стало зменшення глибини вкладеності з 7-8 до 2-3 рівнів, покращення читабельності коду (метод читається як алгоритм), спрощення тестування (кожен окремий метод можна легко протестувати), зменшення цикломатичної складності.
3.5 Інструменти для рефакторингу програмного коду
     Для виконання рефакторингу програмного коду було розглянуто декілька інструментів розробки:
     Visual Studio та Visual Studio Code — надають базові можливості рефакторингу через вбудовані засоби: Extract Method (Ctrl+R, Ctrl+M), Rename (F2), Extract Interface, Quick Actions (Ctrl+.). Ці інструменти використовують аналізатори Roslyn для статичного аналізу коду та надання підказок.
     ReSharper та Rider (JetBrains) — потужні комерційні інструменти, які надають понад 100 різних типів рефакторингів, включаючи Safe Delete, Move Type, Extract Superclass/Interface. Містять понад 2500 автоматичних перевірок коду та можливості автоматичного виправлення проблем.
     SonarQube та SonarLint — інструменти статичного аналізу коду, які виявляють "code smells" (ознаки проблемного коду), вимірюють метрики складності, перевіряють покриття тестами, виявляють дублювання коду та проблеми безпеки. SonarLint інтегрується безпосередньо в IDE та надає підказки під час написання коду.

     Порівняння інструментів показує, що Visual Studio та VS Code підходять для базового рефакторингу та є безкоштовними, ReSharper і Rider надають найбільш потужні можливості рефакторингу але є платними, а SonarQube забезпечує комплексний аналіз якості коду та може використовуватися як у безкоштовній, так і в комерційній версії.
3.6 Правила оформлення програмного коду
     Під час виконання роботи використовувались офіційні рекомендації Microsoft C# Coding Conventions та .NET Runtime Coding Style. Основні правила оформлення коду включають:
– використання чотирьох пробілів для відступів замість табуляції;
– розміщення відкриваючих фігурних дужок на новому рядку (стиль Allman);
– використання PascalCase для імен класів, методів, властивостей та публічних полів;
– використання camelCase для локальних змінних та параметрів методів;
– префікс підкреслення (_) для приватних полів класу;
– обмеження довжини рядка до 120-130 символів;
– використання описових імен змінних та методів, які відображають їх призначення;
– додавання XML-коментарів для публічних методів та класів;
– розміщення одного оператора на одному рядку;
– використання var лише коли тип змінної очевидний з правої частини присвоєння.
   Також було дотримано принципів SOLID при рефакторингу: Single Responsibility Principle (принцип єдиної відповідальності) — кожен метод та клас має одну відповідальність; Open/Closed Principle (принцип відкритості/закритості) - класи відкриті для розширення, але закриті для модифікації; Dependency Inversion Principle (принцип інверсії залежностей) - залежність від абстракцій (інтерфейсів), а не від конкретних реалізацій.
3.7 Практичне застосування методів рефакторингу
     У роботі було продемонстровано практичне застосування методу Extract Method за допомогою Visual Studio. Процес складається з трьох кроків:
1. Виділення фрагменту коду, який потрібно винести в окремий метод.
2. Виклик функції рефакторингу через гарячі клавіші Ctrl+R, Ctrl+M або через контекстне меню Quick Actions (Ctrl+.).
3. Автоматичне створення нового методу IDE з визначенням необхідних параметрів та заміною виділеного коду на виклик нового методу.
     Переваги використання IDE для рефакторингу: швидкість виконання операції (2-3 кліки), автоматичне визначення параметрів та повернених значень, безпечні зміни з перевіркою компіляції, автоматичне оновлення всіх місць виклику методу.
     Усі приклади коду було реалізовано мовою C# з використанням асинхронного програмування (async/await) для операцій введення-виведення, що є стандартною практикою у сучасних веб-додатках на платформі .NET.


ВИСНОВКИ
У ході виконання практичної роботи було досягнуто наступних результатів:
     Було розглянуто три основні методи рефакторингу програмного коду за методологією Мартіна Фаулера: Extract Method, Replace Conditional with Polymorphism та Simplify Conditional Expressions. Кожен з методів вирішує конкретні проблеми якості коду та має чітко визначені сценарії застосування.
     Отримано навички практичного застосування методу Extract Method для виділення фрагментів коду у окремі методи. На прикладі класу OrderService було продемонстровано, як зменшити розмір методу з 60+ рядків до 8 рядків шляхом виділення окремих відповідальностей у методи ValidateOrder(), CalculateTotalAsync(), CalculateDiscount() та SendOrderConfirmationAsync().
     Вивчено застосування методу Replace Conditional with Polymorphism для заміни великих конструкцій switch/if на поліморфні класи. На прикладі системи обробки платежів показано, як конструкція switch на 70+ рядків може бути замінена на систему з інтерфейсом IPaymentHandler, окремими класами-обробниками та фабрикою для вибору відповідного обробника. Це забезпечує дотримання принципу Open/Closed та полегшує розширення системи новими типами платежів.
     Проаналізовано сучасні інструменти для автоматизації рефакторингу: Visual Studio, ReSharper, Rider та SonarQube. Встановлено, що використання вбудованих засобів IDE значно прискорює процес рефакторингу, забезпечує безпеку змін та автоматично оновлює всі місця використання модифікованого коду.
Результати роботи демонструють, що рефакторинг є важливою частиною процесу розробки програмного забезпечення, яка дозволяє підтримувати високу якість коду протягом всього життєвого циклу проекту. Застосування розглянутих методів рефакторингу та використання відповідних інструментів дозволяє значно покращити структуру коду без зміни його функціональності, що в результаті веде до зменшення кількості помилок та прискорення розробки нових функцій.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
    1. Refactoring: improving the design of existing code. Addison-Wesley Professional, 1999. 464 с.
    2. Microsoft C# Coding Conventions. URL: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions (дата звернення: 11.11.2025);
    3. .NET Runtime Coding Style. URL: 
https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md (дата звернення: 11.11.2025);
    4. ASP.NET Core Documentation. URL: https://learn.microsoft.com/en-us/aspnet/core/ (дата звернення: 11.11.2025);
    5. StyleCop Analyzers. URL: https://github.com/DotNetAnalyzers/StyleCopAnalyzers (дата звернення: 11.11.2025);
    6. EditorConfig. URL:   https://editorconfig.org/ (дата звернення: 11.11.2025);
    7. ReSharper Code Inspection. URL:   https://www.jetbrains.com/help/resharper/Code_Analysis__Code_Inspections.html (дата звернення: 11.11.2025).


ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/1Wsqpvl08qw
Хронологічний опис відеозапису:
00:00 — Вступ: представлення теми про методи рефакторингу коду в C# та веб-розробці
00:16 — Зміст презентації: огляд структури (визначення рефакторингу, три методи, інструменти, рекомендації)
00:36 — Що таке рефакторинг: процес зміни внутрішньої структури без зміни поведінки, мета, принципи
01:00 — Коли застосовувати: довгі методи, дуплікація, складна логіка, порушення SOLID; коли не варто
01:35 — Огляд трьох методів: Extract Method, Replace Conditional with Polymorphism, Simplify Conditional Expressions
02:10 — Переваги методів: читабельність, тестованість, підтримуваність, дотримання SOLID
03:24  — Метод 1 Extract Method: опис, проблеми (довгі методи, дуплікація)
03:44 — Приклад проблемного коду: метод на 60+ рядків з множинними відповідальностями
04:10 — Код після рефакторингу: виділення окремих методів, скорочення до 9 рядків
04:42 — Метод 2 Replace Conditional: заміна switch на поліморфізм
04:56 — Приклад проблеми: switch на 70+ рядків для обробки різних типів платежів
05:40 — Рішення: інтерфейс IPaymentHandler, окремі класи, патерн Factory
06:46 — Метод 3 Simplify Conditional: спрощення складних умовних виразів
06:59 — Приклад проблеми: метод з 7-8 рівнями вкладеності
07:37 — Рішення: Guard Clauses, Switch Expressions, зменшення до 2-3 рівнів
08:40 — Інструменти: Visual Studio/VS Code (безкоштовні) з Extract Method, Rename, Quick Actions
09:08 — ReSharper/Rider: 100+ типів рефакторингу, 2500+ перевірок коду
09:28 — SonarQube/SonarLint: статичний аналіз, виявлення code smells, метрики
10:13 — Практичний приклад: покрокова демонстрація Extract Method у Visual Studio
11:34 — Рекомендації: застосування під час розробки, після додавання функцій, перед комітом
11:51 — Висновки: рефакторинг як інвестиція, ефективність методів, частина щоденної роботи
12:27 — Використані джерела та завершення презентації


ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд

Рисунок Б.2 – Слайд змісту презентації


Рисунок Б.3 – Слайд Вступ: що таке рефакторинг?
Рисунок Б.4 – Слайд обраних методів рефакторингу для презентації

Рисунок Б.5 – Слайд переваг обраних методів рефаккторингу
Рисунок Б.6 – Слайд Extract Method(Виділення методу)


Рисунок Б.7 – Слайд з прикладом коду до рефакторингу для методу 1
Рисунок Б.8 – Слайд з прикладом коду після рефакторингу для методу 1

Рисунок Б.9 – Слайд з прикладом коду до рефакторингу для методу 2
Рисунок Б.10 – Слайд з прикладом коду до рефакторингу після методу 2


Рисунок Б.11 – Слайд з прикладом коду до рефакторингу для методу 3
Рисунок Б.12 – Слайд з прикладом коду після рефакторингу для методу 3


Рисунок Б.13 – Слайд з порівнянням інструментів для рефакторингу 
Рисунок Б.14 – Слайд з практичним прикладом Extract Method у IDE Visual Studio


Рисунок Б.15 – Слайд з рекомендаціями та висновками

Рисунок Б.16 – Слайд з списком використаних джерел


Рисунок Б.17 – Слайд дякую за увагу
61


