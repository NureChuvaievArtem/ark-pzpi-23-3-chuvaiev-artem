Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії



Звіт до лабораторної роботи №4
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Програмна система поштових шафок із магнітними замками, що відпираються за допомогою NFC»







Виконав 	
ст. гр. ПЗПІ-23-3                                                               			Чуваєв А.О.
Перевірив
ст. викладач катедри ПІ 					Сокорчук І.П.





                                                                                     
Харків 2025
1. ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
16.12.25
1.0
Створено UseCase та Activity діаграми
2
17.12.25
1.1
Створено та імплементовано IOT клієнт
3
17.12.25
1.2
Створено математичні функції обробки
4
17.12.25
1.3
Створено звіт



2. ЗАВДАННЯ
     Мета роботи: 
     Метою даної лабораторної роботи є розробка програмного забезпечення для IoT пристрою на базі платформи ESP32, що функціонує як інтелектуальний клієнт  системи поштових шафок з NFC-доступом. Робота передбачає створення повноцінної  бізнес-логіки для автоматизованого управління процесами доставки та отримання  посилок, реалізацію математичних алгоритмів оптимального розміщення посилок  у комірках різних розмірів, а також розробку системи збору та статистичного аналізу даних про роботу пристрою.
     Основними завданнями є проектування архітектури IoT клієнта з використанням патерну "машина станів" для керування логікою роботи, забезпечення надійної взаємодії з Backend API через протокол HTTPS/REST, створення локальної бази даних комірок для автономної роботи, імплементація алгоритму багатокритеріальної оцінки ефективності розміщення посилок з урахуванням тривимірних розмірів та об'ємних характеристик. Робота також включає розробку модуля локалізації інтерфейсу з підтримкою кількох мов, побудову UML діаграм для документування архітектури та процесів системи, а також тестування розробленого програмного забезпечення в симульованому середовищі з оцінкою його продуктивності, надійності та ефективності використання апаратних ресурсів.



3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1. РОЗРОБКА БІЗНЕС-ЛОГІКИ СИСТЕМИ
3.1.1. Архітектура IoT клієнта
     IoT клієнт розроблено на базі платформи ESP32 з використанням мови  програмування MicroPython. Система реалізує повноцінний клієнт для  управління поштовими шафками з NFC-доступом.
АПАРАТНЕ ЗАБЕЗПЕЧЕННЯ:
* Мікроконтролер: ESP32 (240 MHz, 520KB RAM)
* Дисплей: LCD 16x2 (I2C, адреса 0x27)
* Клавіатура: Матрична 4x4 (GPIO pins 13,12,14,27 / 26,25,33,32)
* Індикатори: 2 LED (GPIO 2 - успіх, GPIO 4 - помилка)
* Виконавчий пристрій: Реле GPIO 15 для керування замком
* Мережа: WiFi 802.11 b/g/n
ПРОГРАМНІ МОДУЛІ:
a) main.py - Головний модуль системи
* Ініціалізація апаратного забезпечення
* Машина станів (State Machine) з 7 станами
* Обробка введення з клавіатури (read_keypad, lcd_input, lcd_menu)
* Взаємодія з LCD дисплеєм (lcd_print, lcd_clear)
* Локальна база даних з 6 комірками (300x400x500 до 600x600x800 мм)
* Алгоритм оптимального розміщення посилок
* Керування апаратними компонентами (LED, реле) 
b) api_models.py - Моделі даних API
* ValidationResponse: модель валідації з парсингом ролей користувача
* Package: модель посилки з розмірами (height, width, depth, weight)
* LockerPackage: модель зв'язку комірки з посилкою
* Парсери JSON відповідей (parse_validation_response, parse_packages)
c) statistics.py - Статистичний аналіз
* Збір метрик (NFC валідації, посилки, комірки)
* Математичні обчислення (середнє, std deviation)
* Генерація звітів (консоль та LCD формати)
d) localization.py - Система локалізації
* Підтримка англійської та української мов
* 79 локалізованих текстових ключів
* ASCII транслітерація для LCD сумісності
МЕРЕЖЕВА ВЗАЄМОДІЯ:
* Протокол: HTTPS/REST API
* Формат даних: JSON
* Backend: Azure Cloud (packagedeliverybackendwindows...azurewebsites.net)
* 5 основних API endpoints для взаємодії
3.1.2. Машина станів (State Machine)
     Система побудована на основі патерну "State Machine Pattern", що забезпечує  чітку логіку переходів між різними режимами роботи. Реалізація через клас  MailboxStateMachine з методом run() як головним циклом.

СТАНИ СИСТЕМИ ТА ЇХ ФУНКЦІОНАЛ:
1. STATE_IDLE - Початковий стан очікування
* Відображення: "NFC Mailbox / Press any key"
* Очікування натискання будь-якої клавіші
* Перехід > STATE_MAIN_MENU
2. STATE_MAIN_MENU - Головне меню з 4 опціями
* Опції: [1] Courier Mode, [2] Client Mode, [3] EN/UK, [4] Statistics
* Навігація цифровими клавішами 1-4
* Клавіша 'D' - повернення до IDLE
* Переходи > STATE_INPUT_SERIAL або показ статистики
3. STATE_INPUT_SERIAL - Введення серійного номера NFC
* Інтерактивне введення з клавіатури (max 16 символів)
* Операції: цифри/літери (додати), '*' (backspace), '#' (OK), 'D' (назад)
* Відображення введених символів на LCD
* Перехід > Валідація та PROCESSING
4. STATE_PROCESSING / Валідація - Перевірка через API
* POST запит до /api/Nfc/validate з serialNumber
* Парсинг відповіді (userId, name, roles)
* Визначення ролі (Courier/Client) для маршрутизації
* LED індикація: зелений (успіх) / червоний (помилка)
* Переходи > STATE_COURIER_MODE або STATE_CLIENT_MODE або STATE_ERROR
5. STATE_COURIER_MODE - Режим доставки посилок
   Алгоритм роботи:
   a) GET /api/Package/courier?serialNumber > отримання списку посилок
   b) Для кожної посилки (цикл):
* Виклик calculate_optimal_locker(height, width, depth)
* Відображення рекомендації: "Use Locker #N / Eff: X%"
* Відкриття замку (RELAY.on(), LED миготіння)
* Очікування підтвердження '#' (timeout 30s)
* POST /api/Package/place > збереження в Backend
* update_locker_state() > оновлення локальної БД
* record_package_delivered() > статистика
   c) Підсумок: "All done! N delivered"
* Перехід > STATE_MAIN_MENU
6. STATE_CLIENT_MODE - Режим отримання посилок
   Алгоритм роботи:
   a) POST /api/Package/locker/open-all-delivered > список комірок
   b) Для кожної комірки (цикл):
* Відображення: "Locker #N / Opening..."
* Відкриття замку (RELAY.on())
* Очікування підтвердження '#' (timeout 30s)
* POST /api/Package/{id}/receive > відмітка отримання
* clear_locker_state() > очищення локальної БД
* record_package_received() > статистика
   c) Завершення: "All done! Have a nice day"
* Перехід > STATE_MAIN_MENU
7. STATE_ERROR - Обробка помилок
* Відображення повідомлення про помилку (16 символів на LCD)
* Червоний LED миготіння (3 рази)
* Логування в консоль
* Очищення стану (serial_number, user_data)
* Авто-перехід > STATE_MAIN_MENU через 3 секунди
3.1.3. Взаємодія з Backend API
REST API ENDPOINTS та їх використання:
1. POST /api/Nfc/validate - Валідація NFC картки
   Request:  {"serialNumber": "ABC123"}
   Response: {"id": 5, "name": "John Doe", "roles": [{"role": {"name": "Courier"}}]}
   Функція:  validate_nfc(serial_number) > ValidationResponse
2. GET /api/Package/courier?serialNumber={serial} - Посилки для кур'єра
   Response: [{"id": 10, "height": 200, "width": 300, "depth": 400, ...}]
   Функція:  get_courier_packages(serial_number) > List[Package]
3. POST /api/Package/place - Розміщення посилки в комірці
   Request:  {"packageId": 10, "postBoxId": 2, "serialNumber": "ABC123"}
   Response: true (200 OK)
   Функція:  place_package(package_id, postbox_id, serial) > bool
4. POST /api/Package/locker/open-all-delivered - Комірки для клієнта
   Request:  {"serialNumber": "XYZ789"}
   Response: [{"lockerId": 3, "packageId": 15}]
   Функція:  get_delivered_lockers(serial_number) > List[LockerPackage]
5. POST /api/Package/{packageId}/receive?serialNumber={serial} - Отримання
   Response: true (200 OK)
   Функція:  mark_package_received(package_id, serial) > bool
ОБРОБКА ПОМИЛОК:
* Try-catch блоки для всіх мережевих запитів
* Timeout: 30 секунд на операцію
* HTTP статуси: обробка 200, 400, 401, 404, 500
* Fallback: використання локальних даних при збої API
* Логування: всі помилки виводяться в консоль з префіксом "[API]"
3.1.4. Локальна база даних комірок
LOCKER_DATABASE - масив з 6 об'єктів комірок, що зберігається в RAM:

Структура запису:
01: {
02:   'id': int,              # Унікальний ідентифікатор (1-6)
03:   'height': int,          # Висота в міліметрах
04:   'width': int,           # Ширина в міліметрах
05:   'depth': int,           # Глибина в міліметрах
06:   'maxVolume': int,       # Максимальний об'єм в мм³
07:   'currentUsage': int,    # Поточне використання в мм³
08:   'status': str           # 'available' або 'occupied'
09: }

Таблиця 3.1 – Комірки в IOT системі

ID  
Розміри (мм)
Об'єм (л)  
Категорія
1
300×400×500
60         
Мала
2
400×400×600
96
Середня
3
500×500×700      
175
Велика
4
300×400×500
60
Мала
5
600×600×800
288
Дуже велика
6
400×500×600      
122
Середня

ОПЕРАЦІЇ З БАЗОЮ:
update_locker_state(locker_id, package_volume):
* currentUsage += package_volume
* utilization = (currentUsage / maxVolume) × 100
* status = 'occupied'
* Логування змін
clear_locker_state(locker_id):
* currentUsage = 0
* status = 'available'
* Логування очищення
3.2. ПОБУДОВА UML ДІАГРАМ
3.2.1. Діаграма прецедентів (Use Case Diagram)
АКТОРИ:
* Кур'єр (Courier) - доставка посилок
* Клієнт (Client) - отримання посилок  
* Backend API - централізований сервер
ОСНОВНІ ПРЕЦЕДЕНТИ:
Для Кур'єра:
├─ Сканувати NFC картку
│  └─ <<include>> Валідувати NFC через API
├─ Отримати список пакунків кур'єра
├─ Розрахувати оптимальну комірку
│  └─ <<include>> Показати номер комірки
├─ Покласти пакунок в комірку
│  ├─ <<extend>> Керувати LED індикаторами
│  └─ <<extend>> Керувати реле
└─ Підтвердити розміщення через API
Для Клієнта:
├─ Валідувати NFC через API
│  └─ <<include>> Визначити роль користувача
├─ Отримати список доставлених пакунків
├─ Відкрити комірку з пакунком
├─ Взяти пакунок
└─ Підтвердити отримання через API
Спільні прецеденти:
├─ Моніторинг WiFi з'єднання
├─ Показати статистику
└─ Логування подій
3.2.2. Діаграма діяльності (Activity Diagram)
СЦЕНАРІЙ ДОСТАВКИ (COURIER MODE):
     Процес розпочинається зі сканування NFC картки кур'єра. Після сканування  система виконує валідацію через Backend API. Якщо валідація не пройшла успішно, відображається повідомлення про помилку та процес завершується.  У разі успішної валідації система отримує список посилок, призначених для  доставки даним кур'єром.
     Якщо список посилок порожній, система відображає відповідне повідомлення  "Немає посилок для доставки" та завершує роботу. Якщо ж посилки наявні, розпочинається циклічна обробка кожної посилки зі списку.
     Для кожної посилки спочатку викликається функція calculate_optimal_locker() з параметрами висоти, ширини та глибини посилки. Ця функція аналізує  доступні комірки та визначає оптимальну для розміщення. Якщо підходяща  комірка не знайдена, система переходить до наступної посилки в списку.
     У випадку успішного знаходження комірки, на LCD дисплей виводиться  рекомендація з номером комірки та показником ефективності розміщення.  Після цього система відкриває електромагнітний замок комірки через реле  та активує зелений LED індикатор для підтвердження операції.
     Далі система очікує підтвердження від кур'єра (натискання клавіші #), що посилка розміщена в комірці. Встановлено таймаут очікування 30 секунд. Якщо таймаут спрацьовує, замок автоматично закривається. Якщо ж кур'єр натискає клавішу # до закінчення таймауту, система закриває замок,  викликає API функцію place_package() для збереження інформації на Backend,  та оновлює стан комірки в локальній базі даних.
     Після обробки всіх посилок зі списку система виходить з циклу, відображає  підсумкову інформацію про кількість доставлених посилок та завершує процес.

СЦЕНАРІЙ ОТРИМАННЯ (CLIENT MODE):

     Процес починається з валідації NFC картки клієнта через Backend API.  Після успішної валідації система викликає API функцію get_delivered_lockers(),  яка повертає список номерів комірок, в яких знаходяться посилки для даного  клієнта.
     Система входить в цикл обробки кожної комірки зі списку. Для кожної комірки  спочатку на LCD дисплей виводиться її номер та повідомлення про відкриття.  Потім активується реле для відкриття електромагнітного замку комірки,  що дозволяє клієнту отримати доступ до своєї посилки. 
     Система очікує підтвердження від клієнта (натискання клавіші #), що посилка  вилучена з комірки. Встановлено таймаут очікування. Після отримання  підтвердження або спрацювання таймауту система закриває замок комірки.
     Наступним кроком викликається API функція mark_package_received() для  відмітки посилки як отриманої в Backend системі. Після цього виконується   очищення стану комірки в локальній базі даних - обнуляється поточне 
використання та статус змінюється на "available".
     Після завершення обробки всіх комірок зі списку система виходить з циклу, 
відображає повідомлення "Все отримано! Гарного дня!" та завершує процес.
3.3. МАТЕМАТИЧНІ МЕТОДИ ОБРОБКИ ДАНИХ
3.3.1. Алгоритм оптимального розміщення посилок
Функція: calculate_optimal_locker(package_height, package_width, package_depth)
АЛГОРИТМ (покроково):
Крок 1: Обчислення об'єму посилки
\ \ \ \ package_volume\ =\ height\ \times\ width\ \times\ depth\ \ (мм³)
Крок 2: Фільтрація доступних комірок
available_lockers\ =\ filter(LOCKER_DATABASE,\ status\ ==\ \prime available\prime)
sorted_lockers\ =\ sort(available_lockers,\ key=currentUsage,\ asc=True)
Крок 3: 3D перевірка розмірів (з автоматичною ротацією)
      package_dims\ =\ sorted([height,\ width,\ depth])
locker_dims\ =\ sorted([locker.height,\ locker.width,\ locker.depth])
dimensions_fit\ =\ all(p\ <=\ l\ for\ p,\ l\ in\ zip(package_dims,\ locker_dims))
    Пояснення: Сортування дозволяє автоматично знайти оптимальну орієнтацію
Крок 4: Перевірка об'єму
\ \ \ \ available_space\ =\ locker.maxVolume\ -\ locker.currentUsage
\ \ \ \ if\ available_space\ <\ package_volume:
\ \ \ \ \ \ \ \ SKIP\ \ #\ Комірка занадто мала
Крок 5: Обчислення коефіцієнта використання
   \ new_usage\ =\ currentUsage\ +\ package_volume
\ \ \ \ utilization_percent\ =\ (new_usage\ /\ maxVolume)\ \times\ 100\ \ \ \ 
Крок 6: ОЦІНКА ЕФЕКТИВНОСТІ (кусково-лінійна функція)
    Формула:
     70\ +\ (U/60)\times30,\ \ якщо U < 60%      (недостатнє використання)
E(U)\ =\ \ 100,\ \ якщо 60% ≤ U ≤ 85%  (оптимально)
100\ -\ ((U-85)/15)\times30,\ \ якщо U > 85%      (переповнення)
    де U - utilization (%), E - efficiency (%) 
Крок 7: Вибір найкращої комірки
1: if efficiency_score > best_efficiency:
2:   best_locker = {
3:       'lockerId': locker_id,
4:       'utilization': utilization_percent,
5:       'efficiency': efficiency_score,
6:       'volume': package_volume
7:   }

ПЕРЕВАГИ АЛГОРИТМУ:
* Багатокритеріальність (розміри + об'єм + використання)
* Автоматична ротація посилки
* Адаптивна оцінка ефективності
* O(n) складність
* Запобігання переповненню
3.3.2. Система статистичного аналізу
Клас SystemStatistics реалізує збір та аналіз метрик роботи системи.
МЕТРИКИ:
* nfc_validations_success / failed - лічильники валідацій
* packages_delivered / received - лічильники посилок
* lockers_opened - кількість відкриттів
* efficiency_scores[] - масив оцінок ефективності
* locker_utilizations[] - масив використання комірок
МАТЕМАТИЧНІ МЕТОДИ:

1. Середнє арифметичне:
\ \ \ \mu\ =\ (\mathrm{\Sigma}ᵢ₌₁ⁿ xᵢ) / n
Код:
1:    def get_average_efficiency(self):
2:        return sum(self.efficiency_scores) / len(self.efficiency_scores)   

2. Стандартне відхилення:
\ \ \ \sigma\ =\ \sqrt(\mathrm{\Sigma}(xᵢ - μ)² / n)
Код:
1: def get_std_deviation_efficiency(self):
2:   mean = self.get_average_efficiency()
3:   variance = sum((x - mean)**2 for x in self.efficiency_scores) / len(...)
4:   return math.sqrt(variance)   
   
Інтерпретація: σ < 10% означає стабільну роботу алгоритму
3. Коефіцієнт успішності:
SR\ =\ (Success\ /\ Total)\ \times\ 100%
Код:
1: def get_nfc_success_rate(self):
2:   total = self.nfc_validations_success + self.nfc_validations_failed
3:   return (self.nfc_validations_success / total) * 100.0   

Консольний звіт:
    ==================================================
    SYSTEM STATISTICS SUMMARY
    ==================================================
    Uptime:              2.45 hours
    NFC Success Rate:    90.0%
    Total Validations:   50
    Packages Delivered:  15
    Packages Received:   12
    Lockers Opened:      27
    Avg Efficiency:      87.6% (±5.9)
    Avg Utilization:     64.3%
    ==================================================
LCD звіт (16×2):
    Screen 1: "Uptime:2.5h     " / "Valid:90%       "
    Screen 2: "Delivered:15    " / "Received:12     "
    Screen 3: "AvgEff:88%      " / "AvgUtil:64%     "

3.3.3. Обчислення ефективності використання комірок
МЕТРИКИ ЕФЕКТИВНОСТІ:
1. Індивідуальна ефективність комірки:
E\ =\ f(U),\ де U = (Vused / Vmax) × 100%
Функція f(U) описана в розділі 3.3.1
2. Глобальна ефективність системи:
Esystem\ =\ (\mathrm{\Sigma}ᵢ₌₁ⁿ Eᵢ) / n
3. Коефіцієнт оборотності комірок:
K\ =\ (Ndelivered\ +\ Nreceived)\ /\ (L\ \times\ T)\ 
   де L - кількість комірок, T - час у днях


ВИСНОВКИ
     В ході виконання лабораторної роботи №4 було успішно розроблено повноцінний IoT клієнт для системи поштових шафок з NFC-доступом на базі мікроконтролера ESP32. Розроблена система включає чотири програмні модулі на мові MicroPython, що забезпечують комплексну функціональність управління поштовими шафками та інтеграцію з апаратними компонентами, включаючи LCD дисплей, матричну клавіатуру, NFC модуль, LED індикатори та електромагнітне реле.
     Центральним елементом архітектури є машина станів з сімома станами, що забезпечує чітку логіку переходів, обробку помилок та підтримку режимів роботи для кур'єрів та клієнтів. Реалізовано повну інтеграцію з Backend API, що дозволяє виконувати валідацію користувачів та синхронізацію даних в режимі реального часу.
     Розроблено математичний алгоритм оптимального розміщення посилок у комірках, що використовує тривимірну перевірку розмірів з автоматичною ротацією та багатокритеріальну оцінку ефективності. Алгоритм має часову складність O(n) та забезпечує оптимальне використання простору комірок з коефіцієнтом заповнення від 60% до 85%.
     Імплементовано систему статистичного аналізу з математичними методами обчислення середнього арифметичного, стандартного відхилення та коефіцієнтів успішності операцій. Створено модуль локалізації інтерфейсу з підтримкою англійської та української мов. Побудовано повний комплект UML діаграм для документування архітектури системи.
     Розроблена система має практичну цінність та може бути впроваджена в 
поштових відділеннях, офісних будівлях, торгових центрах, житлових комплексах 
та логістичних центрах. Використання сучасних технологій IoT, математичних 
алгоритмів оптимізації та надійних протоколів взаємодії робить систему 
перспективною для масового впровадження.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
    1. Refactoring: improving the design of existing code. Addison-Wesley Professional, 1999. 464 с.
    2. Microsoft C# Coding Conventions. URL: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions (дата звернення: 12.12.2025);
    3. .NET Runtime Coding Style. URL: 
https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md (дата звернення: 12.12.2025);
    4. ASP.NET Core Documentation. URL: https://learn.microsoft.com/en-us/aspnet/core/ (дата звернення: 12.12.2025);
    5. StyleCop Analyzers. URL: https://github.com/DotNetAnalyzers/StyleCopAnalyzers (дата звернення: 12.12.2025);
    6. EditorConfig. URL:   https://editorconfig.org/ (дата звернення: 12.12.2025);
    7. ReSharper Code Inspection. URL:   https://www.jetbrains.com/help/resharper/Code_Analysis__Code_Inspections.html (дата звернення: 12.12.2025).


ДОДАТОК А
Відеозапис
Посилання на відеозапис: https://youtu.be/UjZwa1pxj3Q
Хронологічний опис відеозапису:
0:00-0:45 — Вступ та мета роботи
0:45-2:15 — Архітектура IoT клієнта (апаратне та програмне забезпечення)
2:15-4:00 — Машина станів: структура та переходи між станами
4:00-5:15 — Взаємодія з Backend API (демонстрація endpoints)
5:15-6:30 — Алгоритм оптимального розміщення посилок
6:30-7:30 — Система статистичного аналізу
7:30-9:00 — Демонстрація діаграми прецедентів (Use Case)
9:00-10:30 — Демонстрація діаграми діяльності (Activity)
10:00-17:00 — Демонстрація функціоналу
17:00-17:42 — Висновки та результати

ДОДАТОК Б
Графічні матеріали


Рисунок Б.1 – Діаграма прецедентів IoT клієнта



Рисунок Б.2 – Діаграма діяльності IoT клієнта

ДОДАТОК В
Програмний код
Програмний код знаходиться за посиланням
https://github.com/NureChuvaievArtem/ark-pzpi-23-3-chuvaiev-artem/tree/main/Lab4
61


