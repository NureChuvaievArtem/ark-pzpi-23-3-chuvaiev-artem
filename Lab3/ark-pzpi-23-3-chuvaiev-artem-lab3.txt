Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії



Звіт до лабораторної роботи №3
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Програмна система поштових шафок із магнітними замками, що відпираються за допомогою NFC»







Виконав 	
ст. гр. ПЗПІ-23-3                                                               			Чуваєв А.О.
Перевірив
ст. викладач катедри ПІ 					Сокорчук І.П.





                                                                                     
Харків 2025
1. ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень112.12.251.0Створено титульний лист212.12.251.1Створено CRUD для всіх системних типів313.12.251.2Створено математичні функції обробки414.12.251.3Створено звіт


2. ЗАВДАННЯ
     Мета роботи: 
     Метою даної лабораторної роботи є розробка та впровадження комплексної бізнес-логіки та функцій адміністрування для серверної частини програмної системи доставки посилок. Основне завдання полягає у створенні повнофункціонального адміністративного модуля, який забезпечує ефективне управління всіма сутностями системи через RESTful API, а також реалізацію математичних методів обробки даних для аналітики та оптимізації бізнес-процесів. У рамках роботи необхідно реалізувати повний CRUD функціонал для управління користувачами, посилками, ролями, статусами доставки та категоріями посилок, забезпечити функції резервного копіювання та відновлення даних, експорт та імпорт інформації у різних форматах, а також налаштування системних параметрів. Важливою складовою є впровадження математичних алгоритмів обробки даних, зокрема алгоритму упаковки (Bin Packing - First Fit Decreasing) для оптимізації розміщення посилок у поштових скриньках, аналізу часових рядів для виявлення патернів активності користувачів, статистичного аналізу та прогнозування термінів доставки. Додатково необхідно забезпечити підтримку локалізації та інтернаціоналізації системи для підтримки української та англійської мов, правильного форматування дат, часу та метричних одиниць відповідно до регіональних налаштувань. Результатом виконання роботи має стати стабільна, масштабована та зручна в обслуговуванні серверна частина системи, яка дозволяє адміністраторам ефективно керувати всіма аспектами роботи системи доставки посилок та отримувати детальну аналітичну інформацію для прийняття обґрунтованих рішень.




3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1. Адміністративна частина
    Адміністративна частина системи реалізована через сервіс `AdminService` та набір контролерів, які надають повний функціонал управління сутностями системи та системними операціями. Всі операції реалізовані через RESTful API з використанням патерну Result для обробки помилок.
3.1.1.  Управління користувачами (Users)
     Контролер надає повний CRUD функціонал для управління користувачами системи. Всі операції використовують Generic Repository для доступу до даних та включають зв'язані сутності (ролі та посилки) при отриманні даних.
Приклад коду контролера:
292: Приклад коду контролера:
293: [ApiController]
294: [Route("api/admin/users")]
295: public class AdminUsersController : ControllerBase
296: {
297:     private readonly IGenericRepository<User> _userRepository;
298: 
299:     public AdminUsersController(IGenericRepository<User> userRepository)
300:     {
301:         _userRepository = userRepository;
302:     }
303: 
304:     [HttpGet]
305:     public async Task<IActionResult> GetAll()
306:     {
307:         var result = await _userRepository.GetListByConditionAsync(
308:             includes: new List<Func<IQueryable<User>, IQueryable<User>>>
309:             {
310:                 q => q.Include(u => u.Roles),
311:                 q => q.Include(u => u.Packages)
312:             }
313:         );
314: 
315:         return result.Match(
316:             successStatusCode: 200,
317:             failure: ApiResults.ToProblemDetails
318:         );
319:     }
320: }	

Endpoints:
* Отримати всіх користувачів
GET /api/admin/users
Повертає список всіх користувачів з їх ролями та посилками
Включає зв'язані сутності через Entity Framework Include
* Отримати користувача за ID
GET /api/admin/users/{id}
Повертає детальну інформацію про користувача
Включає ролі та посилки користувача
* Створити користувача
POST /api/admin/users
Створює нового користувача
Тіло запиту: { "emailAddress": "string", "serialNfcData": "string?" }
* Оновити користувача
PUT /api/admin/users/{id}
Оновлює дані користувача
Підтримує часткове оновлення (null значення ігноруються)
* Видалити користувача
DELETE /api/admin/users/{id}
Видаляє користувача з системи
3.1.2. Управління посилками (Packages)
    Контролер надає операції для управління посилками. На відміну від інших сутностей, посилки не можуть бути створені через адмін-панель (створюються через основний API), але можуть бути оновлені та видалені.
359: [ApiController]
360: [Route("api/admin/packages")]
361: public class AdminPackagesController : ControllerBase
362: {
363:     private readonly IGenericRepository<Package> _packageRepository;
364: 
365:     public AdminPackagesController(IGenericRepository<Package> packageRepository)
366:     {
367:         _packageRepository = packageRepository;
368:     }
369: 
370:     [HttpGet]
371:     public async Task<IActionResult> GetAll()
372:     {
373:         var result = await _packageRepository.GetListByConditionAsync(
374:             includes: new List<Func<IQueryable<Package>, IQueryable<Package>>>
375:             {
376:                 q => q.Include(p => p.User),
377:                 q => q.Include(p => p.Category),
378:                 q => q.Include(p => p.DeliveryStatus)
379:             }
380:         );
381: 
382:         return result.Match(
383:             successStatusCode: 200,
384:             failure: ApiResults.ToProblemDetails
385:         );
386:     }
387: }
388:
Endpoints:
* Отримати всі посилки
GET /api/admin/packages
Повертає список всіх посилок з інформацією про користувача, категорію та статус доставки
* Отримати посилку за ID
GET /api/admin/packages/{id}
Повертає детальну інформацію про посилку
* Оновити посилку
     PUT /api/admin/packages/{id}
   Оновлює параметри посилки (висота, ширина, глибина, ID поштової скриньки)
Тіло запиту: { "height": int?, "width": int?, "depth": int?, "postBoxId": int? 
* Видалити посилку
DELETE /api/admin/packages/{id}
Видаляє посилку з системи
3.1.3. Управління ролями (Roles)
    Контролер надає повний CRUD функціонал для управління ролями користувачів у системі.
Endpoints:
* Отримати всі ролі
GET /api/admin/roles
* Отримати роль за ID
GET /api/admin/roles/{id}
* Створити роль
POST /api/admin/roles
Тіло запиту: { "name": "string" }
* Оновити роль
PUT /api/admin/roles/{id}
Тіло запиту: { "name": "string" }
* Видалити роль
DELETE /api/admin/roles/{id}
3.1.4. Управління статусами доставки (Delivery Statuses)
    Контролер надає повний CRUD функціонал для управління статусами доставки посилок.
Endpoints:
* Отримати всі статуси доставки
GET /api/admin/delivery-statuses
* Отримати статус за ID
GET /api/admin/delivery-statuses/{id}
* Створити статус доставки
* POST /api/admin/delivery-statuses
Тіло запиту: { "name": "string" }
* Оновити статус доставки
PUT /api/admin/delivery-statuses/{id}
Тіло запиту: { "name": "string" }
* Видалити статус доставки
DELETE /api/admin/delivery-statuses/{id}
3.1.5. Управління категоріями посилок (Package Categories)
    Контролер надає повний CRUD функціонал для управління категоріями посилок.
Endpoints:
* Отримати всі категорії
GET /api/admin/package-categories
* Отримати категорію за ID
GET /api/admin/package-categories/{id}
* Створити категорію
POST /api/admin/package-categories
Тіло запиту: { "name": "string" }
* Оновити категорію
* PUT /api/admin/package-categories/{id}
* Тіло запиту: { "name": "string" }
* Видалити категорію
DELETE /api/admin/package-categories/{id}
3.1.6. Експорт даних
     Сервіс експортує всі посилки з системи у формат JSON або CSV. Файли зберігаються в директорії exports з унікальним ім'ям, що містить timestamp.
Формула генерації імені файлу:
FileName = "export_" + DateTime.UtcNow.ToString("yyyyMMdd_HHmmss") + "." + format

Формат CSV:
Id,Height,Width,Depth,PostBoxId,UserId,UserEmail,Category,DeliveryStatus,CreatedAt

Endpoint:
     GET /api/admin/system/export/{format}
Приклад відповіді:
Файл завантажується автоматично з відповідним Content-Type:
* JSON: application/json
* CSV: text/csv
506: public async Task<ExportResult> ExportDataAsync(string format)
507: {
508:     try
509:     {
510:         var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
511:         var fileName = $"export_{timestamp}.{format.ToLower()}";
512:         var exportDirectory = Path.Combine(Directory.GetCurrentDirectory(), "exports");
513:         Directory.CreateDirectory(exportDirectory);
514:         var filePath = Path.Combine(exportDirectory, fileName);
515: 
516:         var packages = await _packageRepository.GetAllAsync(
517:             includeProperties: "User,Category,DeliveryStatus");
518:         var recordCount = packages.Count();
519: 
520:         if (format.ToLower() == "json")
521:         {
522:             var json = JsonSerializer.Serialize(packages, new JsonSerializerOptions
523:             {
524:                 WriteIndented = true
525:             });
526:             await File.WriteAllTextAsync(filePath, json);
527:         }
528:         else if (format.ToLower() == "csv")
529:         {
530:             var csv = new StringBuilder();
531:             csv.AppendLine("Id,Height,Width,Depth,PostBoxId,UserId,UserEmail,Category,DeliveryStatus,CreatedAt");
532:             
533:             foreach (var package in packages)
534:             {
535:                 csv.AppendLine($"{package.Id},{package.Height},{package.Width},{package.Depth}," +
536:                              $"{package.PostBoxId},{package.UserId},{package.User?.EmailAddress ?? ""}," +
537:                              $"{package.Category?.Name ?? ""},{package.DeliveryStatus?.Name ?? ""}," +
538:                              $"{package.CreatedOn:O}");
539:             }
540:             
541:             await File.WriteAllTextAsync(filePath, csv.ToString());
542:         }
543:         else
544:         {
545:             throw new ArgumentException($"Unsupported format: {format}");
546:         }
547: 
548:         return new ExportResult
549:         {
550:             Success = true,
551:             FileName = fileName,
552:             FilePath = filePath,
553:             Format = format.ToUpper(),
554:             RecordCount = recordCount
555:         };
3.1.7. Статистика системи
     Сервіс збирає загальну статистику про кількість сутностей у системі та розмір бази даних.
Формула підрахунку:
* TotalUsers = Count(Users)
* TotalPackages = Count(Packages)
* TotalRoles = Count(Roles)
* TotalDeliveryStatuses = Count(DeliveryStatuses)
* TotalPackageCategories = Count(PackageCategories)
Endpoint:
* GET /api/admin/system/statistics
Приклад відповіді:
{
  "totalUsers": 150,
  "totalPackages": 1250,
  "totalRoles": 3,
  "totalDeliveryStatuses": 5,
  "totalPackageCategories": 4,
  "databaseSizeBytes": 0
}

Код методу для отримання статистики:
593: public async Task<DataStatistics> GetDataStatisticsAsync()
594: {
595:     var users = await _userRepository.GetAllAsync();
596:     var packages = await _packageRepository.GetAllAsync();
597:     var roles = await _roleRepository.GetAllAsync();
598:     var deliveryStatuses = await _deliveryStatusRepository.GetAllAsync();
599:     var packageCategories = await _packageCategoryRepository.GetAllAsync();
600: 
601:     return new DataStatistics
602:     {
603:         TotalUsers = users.Count(),
604:         TotalPackages = packages.Count(),
605:         TotalRoles = roles.Count(),
606:         TotalDeliveryStatuses = deliveryStatuses.Count(),
607:         TotalPackageCategories = packageCategories.Count(),
608:         DatabaseSizeBytes = 0
609:     };
610: }
3.1.8. Очищення старих даних
    Сервіс видаляє посилки, які були створені раніше за вказану кількість днів. Це допомагає підтримувати базу даних у чистоті та звільняти місце.
Формула визначення дати відсікання:
CutoffDate = DateTime.UtcNow - TimeSpan.FromDays(daysOld)
Алгоритм очищення:
* Розрахувати CutoffDate
* Знайти всі посилки, де CreatedOn < CutoffDate
* Видалити знайдені посилки
* Повернути звіт про кількість видалених записів
Endpoint:
* DELETE /api/admin/system/cleanup/{daysOld}
Приклад коду методу очищення:
public async Task<CleanupResult> CleanupOldDataAsync(int daysOld)
{
    try
    {
        var cutoffDate = DateTime.UtcNow.AddDays(-daysOld);
        
        var oldPackages = await _packageRepository.GetAllAsync(
            filter: p => p.CreatedOn < cutoffDate
        );

        var deletedCount = 0;
        foreach (var package in oldPackages)
        {
            await _packageRepository.DeleteAsync(package.Id);
            deletedCount++;
        }

        await _packageRepository.SaveAsync();

        return new CleanupResult
        {
            Success = true,
            PackagesDeleted = deletedCount,
            LogsDeleted = 0,
            Message = $"Cleaned up {deletedCount} old packages"
        };
    }
    catch (Exception ex)
    {
        return new CleanupResult
        {
            Success = false,
            Message = $"Cleanup failed: {ex.Message}"
        };
    }
}
3.2. Математична обробка користувацьких даних
3.2.1. Статистичний аналіз (Descriptive Statistics)
    Сервіс обчислює основні статистичні показники для всіх посилок у системі, включаючи розподіл за категоріями та статусами доставки. Аналіз базується на об'ємах посилок та часі їх доставки.
Математичні формули:
1. Середнє значення (Mean):
μ = (Σxᵢ) / n
   де:
* xᵢ - об'єм i-тої посилки (Height × Width × Depth)
* n - кількість посилок
2. Медіана (Median):
Median = { x₍ₙ₊₁₎/₂, якщо n непарне  (x₍ₙ/₂₎ + x₍ₙ/₂₊₁₎) / 2, якщо n парне}
   де :
* x₁, x₂, ..., xₙ - відсортовані за зростанням об'єми посилок
3. Дисперсія (Variance):
σ² = Σ(xᵢ - μ)² / n
4. Стандартне відхилення (Standard Deviation):
σ = √σ² = √(Σ(xᵢ - μ)² / n)
5. Середній час доставки:
AvgDeliveryTime = Σ(LastModifiedOnᵢ - CreatedOnᵢ) / n
Опис значень та їх практичне застосування:
1. Середнє значення об'єму (AverageVolume):
* Надає загальну характеристику типового розміру посилок у системі;
* Дозволяє планувати необхідну місткість поштових скриньок та складських приміщень;
* Використовується для розрахунку середнього навантаження на систему доставки;
* Допомагає визначити оптимальні розміри стандартних поштових скриньок;
* Приклад: якщо середній об'єм 9000 см³, це означає, що більшість посилок мають розміри близько 30×20×15 см.
2. Медіана об'єму (MedianVolume):
- Показує центральне значення в упорядкованому списку об'ємів посилок
- Більш стійка до викидів (великих або дуже малих посилок), ніж середнє значення
- Дає реальне уявлення про типовий розмір посилки без впливу екстремальних значень
- Дозволяє виявити асиметрію розподілу: якщо медіана значно відрізняється від середнього, це вказує на наявність викидів
- Приклад: медіана 8500 см³ при середньому 9000 см³ вказує на те, що є кілька дуже великих посилок, які збільшують середнє значення
3. Дисперсія (Variance):
- Вимірює ступінь розкиду значень об'ємів посилок навколо середнього значення
- Велика дисперсія означає значну різноманітність розмірів посилок у системі
- Допомагає оцінити необхідність різних типів поштових скриньок (малі, середні, великі)
- Використовується для планування запасів та оптимізації використання простору
- Приклад: дисперсія 6252500.25 вказує на значну варіативність розмірів посилок
4. Стандартне відхилення (StandardDeviation):
- Показує середнє відхилення об'ємів посилок від середнього значення
- Має ту саму одиницю виміру, що й об'єм (см³), тому легше інтерпретується, ніж дисперсія
- Дозволяє оцінити діапазон типових значень: більшість посилок знаходяться в межах ±2 стандартних відхилень від середнього
- Використовується для виявлення аномальних посилок (викидів)
- Приклад: стандартне відхилення 2500.5 см³ означає, що типові посилки відрізняються від середнього приблизно на 2500 см³
5. Розподіл за категоріями (PackagesByCategory):
- Показує кількість посилок кожної категорії (Standard, Express, Economy)
- Дозволяє аналізувати попит на різні типи послуг доставки
- Допомагає планувати ресурси та персонал для обробки різних категорій
- Використовується для оптимізації ціноутворення та маркетингових стратегій
- Приклад: 800 стандартних, 300 експрес та 150 економ посилок показує перевагу стандартної доставки
6. Розподіл за статусами (PackagesByStatus):
- Відображає поточний стан усіх посилок у системі
- Дозволяє відстежувати ефективність процесу доставки
- Допомагає виявити проблемні ділянки (велика кількість посилок у статусі "Pending" або "In Transit")
- Використовується для моніторингу продуктивності системи та планування ресурсів
- Приклад: 1000 доставлених, 200 у транзиті та 50 очікуючих показує високу ефективність системи
7. Середній час доставки (AverageDeliveryTimeHours):
- Вимірює середній час від створення посилки до її доставки
- Використовується для встановлення очікувань клієнтів та планування термінів
- Допомагає виявити проблеми в логістичному ланцюжку
- Приклад: середній час 48.5 годин означає, що типова посилка доставляється приблизно за 2 дні
     Статистичний аналіз дозволяє отримати уявлення про розподіл даних у системі, виявити аномалії та оптимізувати процеси доставки. Використання медіани разом із середнім значенням дає більш точну картину, оскільки медіана стійка до викидів.
3.2.2. Прогнозування часу доставки (Linear Regression)
     Алгоритм використовує лінійну регресію для прогнозування часу доставки на основі історичних даних. Модель враховує об'єм посилки та її категорію для більш точного прогнозу.
Математична модель:

1. Лінійна регресія:
y = β₀ + β₁x + ε
   де:
- y = час доставки (години)
- x = об'єм посилки
- β₀ = вільний член (intercept)
- β₁ = коефіцієнт нахилу (slope)
- ε = помилка

2. Розрахунок коефіцієнтів методом найменших квадратів:
β₁ = (n·Σxy - Σx·Σy) / (n·Σx² - (Σx)²)
β₀ = (Σy - β₁·Σx) / n
3. Коефіцієнт детермінації (R²):
R² = 1 - (SS_res / SS_tot)
   де:
- SS_res = Σ(yᵢ - ŷᵢ)² (сума квадратів залишків)
- SS_tot = Σ(yᵢ - ȳ)² (загальна сума квадратів)
- ŷᵢ = передбачене значення
- ȳ = середнє значення y
4. Корекція на категорію:
PredictedTime = (β₀ + β₁·Volume) × CategoryFactor
   де CategoryFactor:
- Express: 0.5 (50% швидше)
- Standard: 1.0 (базовий)
- Economy: 1.5 (50% повільніше)
5. Рівень впевненості:
Confidence = R² × 100%
     Лінійна регресія є простим та ефективним методом для прогнозування на основі історичних даних. Вона дозволяє враховувати залежність між об'ємом посилки та часом доставки, що допомагає планувати ресурси та інформувати клієнтів про очікуваний час доставки.
3.2.3. Аналіз часових рядів (Time Series Analysis)
     Аналіз активності користувачів використовує методи аналізу часових рядів для виявлення патернів у використанні системи. Алгоритм групує дані за годинами та днями тижня, розраховує тренд активності та визначає пікові періоди.
Математичні формули:

1. Групування за годинами:
PackagesByHour[h] = Count({p | p.CreatedOn.Hour == h})
   де h ∈ [0, 23]
2. Групування за днями тижня:
PackagesByDayOfWeek[d] = Count({p | p.CreatedOn.DayOfWeek == d})
   де d ∈ {Monday, Tuesday, ..., Sunday}
3. Розрахунок тренду:
Trend = ((Count_SecondHalf - Count_FirstHalf) / Count_FirstHalf) × 100%
   де:
- Count_FirstHalf = кількість посилок у першій половині періоду
- Count_SecondHalf = кількість посилок у другій половині періоду
4. Визначення пікової години:
PeakHour = argmax_h(PackagesByHour[h])
     Аналіз активності користувачів дозволяє виявити патерни використання системи, оптимізувати навантаження на сервер та планувати обслуговування в періоди низької активності. Виявлення трендів допомагає передбачити майбутнє навантаження та розподілити ресурси ефективніше.


ВИСНОВКИ
     У рамках лабораторної роботи  було реалізовано комплексну систему бізнес-логіки та адміністрування для серверної частини системи доставки посилок.
     Система включає математичну обробку даних та повнофункціональний адміністративний модуль. Математична частина реалізує статистичний аналіз з розрахунком основних метрик, таких як середнє значення, медіана, дисперсія та стандартне відхилення об'ємів посилок, що дозволяє отримати детальну картину розподілу даних у системі та виявити аномалії. Додатково реалізовано прогнозування часу доставки за допомогою лінійної регресії, яка враховує об'єм посилки та її категорію для більш точного передбачення термінів доставки. Аналіз активності користувачів реалізовано за допомогою методів часових рядів, що дозволяє виявляти патерни використання системи, групувати дані за годинами та днями тижня, розраховувати тренди активності та визначати пікові періоди для оптимізації навантаження на сервер та планування обслуговування.
     Адміністративна частина системи надає повний CRUD функціонал для управління всіма сутностями системи, включаючи користувачів, посилки, ролі, статуси доставки та категорії посилок. Всі операції реалізовані через RESTful API з використанням патерну Result для надійної обробки помилок та повернення структурованих відповідей. Система підтримує експорт даних у формати JSON та CSV з автоматичним генеруванням унікальних імен файлів, що містять timestamp для зручної ідентифікації. Реалізовано управління системною конфігурацією, що дозволяє налаштовувати мову за замовчуванням, часовий пояс, режим обслуговування та інші параметри системи. Додатково система надає збір загальної статистики про кількість сутностей у системі та функцію очищення старих даних, яка видаляє посилки, створені раніше за вказану кількість днів, що допомагає підтримувати базу даних у чистоті та звільняти місце.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
    1. Refactoring: improving the design of existing code. Addison-Wesley Professional, 1999. 464 с.
    2. Microsoft C# Coding Conventions. URL: https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions (дата звернення: 12.12.2025);
    3. .NET Runtime Coding Style. URL: 
https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md (дата звернення: 12.12.2025);
    4. ASP.NET Core Documentation. URL: https://learn.microsoft.com/en-us/aspnet/core/ (дата звернення: 12.12.2025);
    5. StyleCop Analyzers. URL: https://github.com/DotNetAnalyzers/StyleCopAnalyzers (дата звернення: 12.12.2025);
    6. EditorConfig. URL:   https://editorconfig.org/ (дата звернення: 12.12.2025);
    7. ReSharper Code Inspection. URL:   https://www.jetbrains.com/help/resharper/Code_Analysis__Code_Inspections.html (дата звернення: 12.12.2025).


ДОДАТОК А
Відеозапис
Посилання на відеозапис: https://youtu.be/6scrZWJd9s0
Хронологічний опис відеозапису:
0:00-0:45 — Вступ та мета роботи
0:45-2:00 — Адміністративна частина: огляд CRUD операцій
2:00-3:30 — Управління користувачами та посилками (демо API)
3:30-4:30 — Системні операції: експорт, статистика, очищення
4:30-5:30 — Математична обробка: статистичний аналіз
5:30-6:30 — Прогнозування часу доставки (лінійна регресія)
6:30-7:30 — Аналіз часових рядів та активності користувачів
7:30-9:00 — Демонстрація діаграм (послідовностей та активності)
9:00-11:00 — Демонстрація роботи API через Swagger
11:00-12:00 — Висновки та результати


ДОДАТОК Б

Рисунок Б.1 – Діаграма послідовностей



Рисунок Б.2 – Діаграма Активності

Рисунок Б.1 – Swagger API

Рисунок Б.2 – Результат експорту з БД


ДОДАТОК В
Програмний код
Програмний код знаходиться за посиланням
https://github.com/NureChuvaievArtem/ark-pzpi-23-3-chuvaiev-artem/tree/main/Lab3
61


